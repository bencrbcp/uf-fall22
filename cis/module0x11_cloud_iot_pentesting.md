# MODULE 0x11 LECTURE 0x410 - HACKING IOT DEVICES

## "The IoT is your future"

"The IoT is your Future" - IoT Manufactuerers

We are told that networking our thermostat will provide us with inumerable benefits.

We are also being told that people from across the world are going to hack the bejeezus out of us thru the IoT


## Properties of IoT devices

- They can act on their own.
- They can harbor external entities (code, data) within themselves
- They can be coerced by others to act w/ malicious intent
- Some people offer services to rid such devices of their malicious entities

* Read: [Internet of Things as applied demonology](https://www.jwz.org/blog/2015/10/internet-of-things-as-applied-demonology/)


## What can an IoT lightbulb do?

- DIY hauntings and trickery (flickering lights)
- Streamline breaking and entering
- Potentially induce seizures


## How did this project start?

https://www.youtube.com/watch?v=Wq2c2zRgDWs -- talk by Thomas Wilson

With an `nmap -Pn <ip>`
    - UDP port 9999 was open on this lightbulb
    - Communication happening? Test with wireshark

* Wireshark was run on the network.
    - Lightbulb was sending out traffic to the network broadcast address
    - Data segments were of different lengths (actual communication was happening)
    - Port 9999 was the only destination port
    - No traffic was observed _going_ to the lightbulb (likely due to the wireless adapter being used) -- The Alfa AWUS051NH would prob capture this, but another method was used to reveal this data that was not captured.


## TP-link smart plug reverse engineering

https://www.softscheck.com/en/blog/tp-link-reverse-engineering/

* They reverse engineered a TP-Link Smart Plug and produced a Python tool to manipulate those devices.
    - The light bulb under attack is a TPLink LB-120.
    - Perhaps their code could be leveraged

* TP-Link smart plugs used autocipher for data encoding
    - Stroetmann and Esser's tool didn't work out of the boxon the LB-120 b/c it connected to a TCP port rather than UDP

* Some of the smart plug functionality of the python tool worked w/ the light bulb when appropriately modified (`getsysinfo` worked)
    - This demonstrated that the bulb used the same autocipher


## Reverse engineering

Tools used:
- dex2jar by pxb1988 (decompiles.dex to .jar)
- jadx by skylot (converts .jar, .dex, .apk, .class to java) produced highly readable source code
- No native code was encountered, so no disassembler needed


## Why is it so easy to reverse engineer Java?

* Java is intended to run on numerous platforms
    - The bytecode generated by the compiler has loads of information to help the platform use it properly
    - Dalvik bytecodes do not obscure much detail
    - Java -> Java bytecode -> Dalvik bytecode -> apk file

* At runtime, Zygote transforms Dalvik bytecodes into OAT (Optimized Android fileType)


## Javac compilation

* javac produces bytecodes from Java in a very direct way
    - Check [this diagram](https://i.imgur.com/YMNcbH6.png) -- notice the analogue to Programming Language Concepts class


## App construction

Java bytecode: .java source -> javac compiler -> .class files

Dalvik bytecode: .class files & .jar files > dx -> classes.dex

APK construction: classes.dex file & resource files -> aapt process -> .apk file

* All of this is very straightforward
    - Almost nothing is obscured.


### QUIZ ACCESS CODE
Gil Scott-Heron - Did you hear what they said?


## APP OBFUSCATION

* ProGuard
    - Commercial obfuscator
    - Check [this diagram](https://i.imgur.com/3fvGEsL.png) to check how ProGuard fits into app construction process
    - Trivial use: modify variables/method names


## Finding autocipher

Correspondance between smart plug autocipher and light bulb auto cipher.
    - the variable `bArr` was looked for, matched in both light bulb and smart plug


## How does this autocipher work?

* The key is null

* The IV is a single byte value

* Method A shifts ciphertext and XORs w/ itself to yield plaintext
    - See [this image](https://i.imgur.com/aGFl2dJ.png)

* Method B Uses the the plaintext as the subsequent IVs
    - See [this image](https://i.imgur.com/URdTY3z.png)

* This, of course, allows initial IV to be brute-forced to decode the first character
    - The rest follow directly
    - Although no bruteforcing was necessary in this case because the IV could be found in the source code


## Initial success from smartplug script

* The smartplug script was modified to use UDP
    - It sent commands to light bulb port 9999
    - `getsysinfo` was able to be executed
    - But... no wifi data could be collected from port 9999 on the light bulb (though it clearly worked b/c it succeeded and provided dashboard information)

* So how can we capture packets?


## Use a rooted Android smartphone!

* Kali Linux NetHunter (mobile Kali) was installed on a rooted phone
    - Supports use of `chroot`
    - Numerous tools are provided, including tcpdump which was used to capture network traffic from phone

* What traffic was intercepted?
    - The broadcasts to port 9999 from light bulb
    - As well as packets destined for light bulb's port 9999
    - Traffic from the phone's controlling app and the light bulb could now be intercepted


## How does light bulb setup work?

* TPLink light bulbs create their own wifi network during setup
    - This allows you to provide your wifi network's SSID and PSK to allow the light bulb to connect to your network
    - [Here](https://i.imgur.com/kul0Yw5.png) is a picture of the reverse engineered code that shows this)

* Alexa and other devices do this using SSL/TLS (which is much better)
    - Using HTTP for this opens the network up to an evil-twin attack
    - The exploit approach: break a light bulb to force setup of a new one in order to capture network credentials

## Other interesting commands

* A `get_light_state service` call was observed
    - If a get method exists, a set method will often exist
    - Inspection of commands in packet dumps showed that the set method was named `transition_light_state`

* Firmware can be downloaded from any URL:
    - `{"system":{"download_firmware":{"url":"http://..."}}}`
    - The state of the download can be queried with `{"system":{"get_download_state":{}}}`
    - Once the download finishes, you can flash that firmware onto device with `{"system":{"get_download_state:{}}}`


## Firwmare update method

1. Smart device reports to the cloud
2. App queries devices it controls and receives response from cloud
3. If app detects out-of-date firmware, it requests update info and cloud responds with a URL
4. Firmware is flashsed


## Firmware capture method

In step 2, the cloud reports the light bulb identity and current firmware version to the ap.

* When the app requests firmware update information from the cloud, the app reports light bulb identity and current firmware version to the cloud.
    - The cloud trusts the data sent by the app.
    - So... one can downgrade the reported light bulb firmware version to any valid firmware version and receive an update
    - Firmware was captured
