# MODULE 0x050 LECTURE 0x140 - BUFFER OVERFLOWS

## Process memory organization

* strycpy() does not know size of buffer in the sample code
    - What happens to data when it goes past that buffer?

* rbp (base pointer) points at the start of the current stack frame

* X64 object code details
    - Addresses occupy 8 bytes
    - Stack pointer register is %rsp
    - Stack grows from high addresses to low
    - Push decrements the stack pointer, pop increments it
    - The base pointer (or frame) is %rbp
    - Up to four integer arguments are passed in registers
    - On call, the return address is pushed onto stack, so after instruction finishes, %rsp points to a location containing ret address
    - On return, the value pointed to b rsp is popped into the instruction pointer (%rip)


## How do we control execution?

* Old school method was to write shellcode into the stack
    - i.e. code to execute /bin/sh
    - Make sure the ret address location is overwritten by an address in the code that will cause its execution

* Many pitfalls and ways to avoid them (Control Flow Integrity/CFI)
    - ASLR (Address Space Layout Randomization)
    - Stack canaries
    - No execute stack pages
    - Now that CFI precautions have made stack smashing attacks difficult, techinques have been developed to defeat them.





# MODULE 0x050 LECTURE 0x150 - CFI

## Program control flow graph

A graph with _nodes_ corresponding to basic blocks or instructions (maximal sequences of non-branching instructions)
and _edges_, corresponding to control-flow transfer instructions e.g. jumps, calls.

Control flow may be:
- Direct: Target instructions are either implicit or provided as part of the instruction
- OR Indirect: Target instructions are provided by data stored in registers or memory locations referenced by the instruction


## Control Flow Integrity

Control Flow Integrity for a program is preserved if the set of possible control flow transfers is limited to those that are **strictly required** for correct program execution.

To preserve CFI, systems typically employ a two-phase process:
1. Analyze (to produce the CFG)
2. Enforcement (to ensure that all branches to be encountered at runtime correspond to all edges in the CFG.

CFI mechanisms usually assume that code integrity so direct branches are assumed to be correct.
Various methods are employed to enforce correspondance of indirect branches to graph edges produced during analysis.


## Axes of comparing CFI methods

1. Performance
    - CFI approaches today are shown to incur ~20% performance penalty)
2. Security
    - want to limit # of indirect branches that could occur incorrectly
    - Average Indirect target Reduction (AIR) is a measure of security improvement.
    - "targets" refers to branch locations for any control flow transfer; we want to lower these to only the ones that are correct
    - Typical AIR numbers are ~99%


## Analysis of CFI methods

* Qualitative
    - Precision in the forward direction
    - Precision in the backward direction
    - Supported control-flow transfer type
    - Reported performance
* Quantitative
    - SPEC CPU2600 Benchmark (compares non CFI vs CFI programs to compare branching properties)


## Reducing the possible transfers

* Most CFI methods operate by reducing the set of possible transfers using the CFG.
    - An equivalence class is the set of valid targets for a given indirect control-flow transfer
    - In the ppt sample, foo() and bar() are part elements of such an equivalence class


## Control flow transfer classes

* Forward:
    - Direct jump
    - Direct call
    - Indirect jump (switch or procedure linkage table)
    - Indirect call (function pointers, vtable dispatch [OOP], send-method dispatch [OOP])

* Backward:
    - Return
    - Complex control-flow (exception handling)


## Existing methods of control flow analysis

* No forward branch validation
* Ad-hoc algorithms and heuristics
* Context and flow-insensitive analysis
* Labeling equivalence classes
* Class heirarchy analysis
* Rapid-type analysis
* Flow-sensitive analysis
* Context-sensitive analysis
* Context AND flow-sensitive analysis
* Dynamic analysis (optimistic)


## QUIZ ACCESS CODE

Bob Dylan - Masters of War


## Existing methods of backward control transfer analysis

* No backward branch validation (bad)
* Labelign equivalence classes
* Shadow stack (maintain program stack that identifies control transfers we expect to see)


## Two basic CFI methods

1. Address Space Layout Randomization (ASLR)
    - Main program Heap and Stack will be placed at random locations in memory
    - Library code may or may not be compiled to support ASLR (if a single component of a program doesn't use ASLR, then ASLR is not really happening)
    - (Non ASLR library code can be targeted)

2. Data Execution Prevention (DEP)
    - Supported by NX (No eXecution enforcement -- provided by CPU)
    - An exception is raised if EIP is set to an address for which the NX bit is set


## What is ROP and why does it hurt so much?

* Early binary exploitation methods would write code into memory, then overwrite an indirect transfer location to transfer control to that code
    - If you can't transfer control to an NX-protected area of memory, then we need ROP

__Return Oriented Programming (ROP)__ employs code that contains indirect returns, overwriting return addresses to employ code that already appears in process memory without modifying instructions

* A ROP **gadget** is a sequence of process instructions that ends with an indirect return or branch

* ROP programming is achieved by assembling a sequence of gadgets to achieve a program's aim, then constructing a series of indirect return points that can be written to the stack to arrange for that sequence of gadgets to be executed (by returning successive gadgets one-at-a-time).

* ROP has been proven to be Turing-complete


## ROP Plan

1. [Find gadgets](https://github.com/JonathanSalwan/ROPgadget)
    - Store gadget addresses (and subsequent arguments to be popped) on the stack, starting at return address location





# MODULE 0x050 LECTURE 0x160 - METASPLOIT INTRO

## What is Metasploit?

Open-source project from 2003 that has, at its center, the metasploit framework.

Has __exploits__ and __payloads__ (script kiddie's dream).

## Running Metasploit

- Initialize metasploit database with `sudo msfdb init`
- `msfconsole`


## Selecting an exploit

* Search by CVE:`msf> search 2007-2447`


## Exploitation plan

1. Find vuln
2. Use exploit that exploits it (e.g. `use multi/samba/usermap_script`)
3. Set options for the exploit
4. Determine what payload to use (`show payloads` to only show applicable ones)
5. `show options` again for payload options, or even `show advanced`
6. Run (`run` or `exploit`)





# MODULE 0x050 LECTURE 0x170 - USING THE METERPRETER

## Meatsploit module rank

* How good an exploit is
    - excellent: will never crash the service
    - great (has default target and will auto-detect or use application-specific return address)
    - good (has default target which is the common case)
    - normal (reliable but depends on a specific version)
    - average (unreliable or difficult to exploit)
    - low (nearly impossible to exploit)
    - manual (unstable or difficult to exploit or of no use unless configured by user)

* Use this as an upper-bound for the actual rating


## What is the MS-08-067 API exploit?

Exploits a vulnerability assigned **CVE-2008-4250**.
This CVE numbering system maintained by MITRE Corp. keeps track of vulnerabilities.

* CVE-2008-4250 concerns a buffer overflow in the Windows SMB (Server Message Block) service.
    - Same vulnerability is exploited by the _Conficker_ worm and _Stuxnet._
    - Asigned a *great* ranking in Metasploit
    - Surprisingly, many hosts still vulnerable to it.
    - We won't be using MS-08-067, but we can do almost as well with a number of other vulnerabilities.

### MS17-010

* EternalBlue
    - "The new MS-08-067"


## What payload should I use for a given exploit?

Many payloads available, but use **meterpreter** for:
- stealth
- reliability
- flexibility

* Meterpreter
    - Provides a command interpreter that runs as the user who was executing the exploited prcoess
    - Most useful command: `help`
    - Supports listing of system files, file upload and download, remote shell execution, etc.
    - Windows version supports the relatively stable `getsystem` function to escalate privileges to the user `NT AUTHORITY/SYSTEM`
    - Effectiveness of `getsystem` lower in newer Windows versions.

### How does the Meterpreter do this?

* Meterpreter uses a **stager** to download code and inject into a DLL.
    - If a vuln has limited space for writing payload instructions, it's necessary to do something similar to bootstrap loading to get a large payload delivered

* The meterpreter payload is small, but Meterpreter itself is large.
    - The payload determines how the meterpreter on the victim machine is to interact with your Metasploit Framework (`bind_tcp`, `reverse_tcp`)

* In Windows, meterpreter runs using DLL injection
    - It is written into the code section of executing library code -- no file is ever created on the exploited host.

* TLS/1.0 is used to encrypt all communications between attacker and victim

 * Can add new features at runtime.

### Meterpreter communication security

Meterpreter uses TLS for _obfuscation,_ not security

* TLS/1.0 **is insecure.** It is susceptible to [padding oracle attack](https://www.iacr.org/archive/eurocrypt2002/23320530/cbc02_e02d.pdf)
    - A good video on padding oracle: https://www.youtube.com/watch?v=O5SeQxErXA4
    - Wes McGrew (of Horne Cyber) presented at [BlackHat/DEFCON](https://www.youtube.com/watch?v=pSGAu4PZ7bw) about lack of security in pentesting educational materials and tools.
    - In the talk, he demosntrated the ability to hijack a meterpreter session

* Metasploit supports "Paranoid Mode" to avoid this problem that Wes identified.
    - Paranoid mode uses a self-generated or existing certificate and certificate pinning in the payload.
    - It is recommended that Paranoid Mode be used in actual penetration tests.

### Meterpreter versions

* `msf> grep meterpreter show payloads`
    - When executed in the context of an exploit, gives us a list of the different available meterpreter payloads (if any)

* In general, the ports listening for meterpreter paylaods only remain while they wait for the connection to be established between attacker and victim.
    - After establishing it, the port appears as closed.


## BIND TCP Options

* In a Bind TCP connection, a listening meterpreter service is started **on the victim machine**
    - This service is listening for the attacker machine to connect (binds) to it.

* If the blue team of the victim machine's network is paying attention, they __will__ notice that a port is open on one of their machines that should not be open.
    - This is the main downside of Bind TCP.
    - Firewall rules may also get in the way of bind connections (why would they let a machine connect to their servers on a port that should not be open for it?)


## REVERSE HTTP Options

Slightly more complicated than Bind TCP:

* With a Reverse HTTP connection, we start a listening meterpreter service **on the attacker machine**
    - Then, a meterpreter reverse client connects from the victim machine to the attacker macine.

* This provides for a stealthier connection (no port needs to be opened up on victim machine, just on attacker)
    - A victim host trying to connect to something out on the internet at large is more common than a victim host trying to provide a service.
    - Even stealthier/more likely to succeed if we host the reverse shell listener e.g. on port 80, as this corresponds to more allowable firewall rules.


## Meterpeter Sessions

The Meterpreter (like any other interactive session that a Metasploit payload implements) runs in a __session.__

* More than one session may be active at a time, but you can only interact with one at a time.
    - The active session is said to be in the **foreground**.
    - The rest are **background** sessions.

* The `sessions` command is used to manage sessions
    - With the `-h` flag, it provides help on its capabilities.
    - Followed by a session number (e.g. `sessions 3`) it will enter a session and let you interact with it

* You can stop a session by typing Ctrl+Z, and then ask for it to be put in the background
    - Background sessions can be resumed with the sessions command.

* Random note: Be careful with using port 4444 with meterpreter and other stuff
    - ICS and IDS systems often look for this port being used, as it is common with attacks

### Dumping Windows hashes with Meterpreter

* In the meterpreter Windows session, simply type `hahsdump`
